## Interactuando con chatgpt

### Conociendo p5js y estructura HTML

- El link del editor es: https://editor.p5js.org/
- Se recomienda registrarse con google o github
- 

Vista del editor de p5js

![p5js vista](/imagenes/clase01/p5js_vista.png)

1. Prompt: "quiero construir el juego pong con javascript.
usar la libreria p5js
que sea un juego simple entre el jugador y la computadora
crear solo el archivo .html"

Respuesta: "Aquí tienes un archivo HTML simple que utiliza la librería p5.js para crear una versión básica del juego Pong. En este juego, el jugador controla una paleta a la izquierda usando el ratón, mientras que la computadora controla la paleta de la derecha. La pelota rebota entre las paletas, y el objetivo es evitar que la pelota pase por tu paleta."

```html
   <!DOCTYPE html>
    <html lang="es">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Pong Game</title>
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
        <script src="script.js"></script>
    </body>
    </html>


```

```javascript
    let playerPaddle, computerPaddle, ball;
    let playerScore = 0, computerScore = 0;

    function setup() {
        createCanvas(800, 400);

        // Inicializar paletas y bola
        playerPaddle = new Paddle(true);
        computerPaddle = new Paddle(false);
        ball = new Ball();
    }

    function draw() {
        background(0);

        // Mostrar puntaje
        displayScores();

        // Mostrar y mover las paletas y la bola
        playerPaddle.show();
        playerPaddle.move();

        computerPaddle.show();
        computerPaddle.aiMove(ball);

        ball.show();
        ball.move();

        // Detectar colisiones con las paletas
        ball.checkPaddleCollision(playerPaddle);
        ball.checkPaddleCollision(computerPaddle);

        // Verificar si alguien ha anotado
        ball.checkScore();
    }

    class Paddle {
        constructor(isPlayer) {
            this.width = 20;
            this.height = 100;
            this.x = isPlayer ? 30 : width - 50;
            this.y = height / 2 - this.height / 2;
            this.isPlayer = isPlayer;
        }

        show() {
            fill(255);
            rect(this.x, this.y, this.width, this.height);
        }

        move() {
            if (this.isPlayer) {
                this.y = constrain(mouseY - this.height / 2, 0, height - this.height);
            }
        }

        aiMove(ball) {
            if (!this.isPlayer) {
                if (ball.y < this.y + this.height / 2) {
                    this.y -= 5;
                } else if (ball.y > this.y + this.height / 2) {
                    this.y += 5;
                }
                this.y = constrain(this.y, 0, height - this.height);
            }
        }
    }

    class Ball {
        constructor() {
            this.size = 20;
            this.reset();
        }

        reset() {
            this.x = width / 2;
            this.y = height / 2;
            this.xSpeed = random([-5, 5]);
            this.ySpeed = random(-3, 3);
        }

        show() {
            fill(255);
            ellipse(this.x, this.y, this.size, this.size);
        }

        move() {
            this.x += this.xSpeed;
            this.y += this.ySpeed;

            if (this.y <= 0 || this.y >= height) {
                this.ySpeed *= -1;
            }
        }

        checkPaddleCollision(paddle) {
            if (this.x - this.size / 2 < paddle.x + paddle.width &&
                this.x + this.size / 2 > paddle.x &&
                this.y - this.size / 2 < paddle.y + paddle.height &&
                this.y + this.size / 2 > paddle.y) {
                this.xSpeed *= -1;
                this.x = paddle.isPlayer ? paddle.x + paddle.width + this.size / 2 : paddle.x - this.size / 2;
            }
        }

        checkScore() {
            if (this.x < 0) {
                computerScore++;
                this.reset();
            } else if (this.x > width) {
                playerScore++;
                this.reset();
            }
        }
    }

    function displayScores() {
        textAlign(CENTER);
        textSize(32);
        fill(255);
        text(playerScore, width / 4, 50);
        text(computerScore, 3 * width / 4, 50);
    }

```


```css
    body {
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #282c34;
    color: white;
    font-family: Arial, sans-serif;
    }

    canvas {
        border: 4px solid white;
        background-color: #000;
    }

```

Resultado:

- Paddle Class: Define la paleta del jugador y la de la computadora. La computadora sigue la posición de la bola para simular una IA básica.
- Ball Class: Define la pelota, sus movimientos y las colisiones con las paletas.
- Movimiento: La paleta del jugador se mueve con el mouse, y la de la computadora sigue la bola automáticamente.
- Puntaje: El puntaje se actualiza cada vez que la bola sale por un lado de la pantalla

![pong_v1](/imagenes/clase01/pong_v1.png)


### Ajustando dificultad y creando marcos

- el codigo debe ser revisado y evaluado
- se pide a la ia que genere el marco del juego: "arregla el codigo para agregar un marco al juego"
- para delimitar el espacio del juego se le puede pedir a la ia que use "contraint"

Cambios en el javascript:

```javascript	
    let playerPaddle, computerPaddle, ball;
    let playerScore = 0, computerScore = 0;
    const PADDING = 10; // Espacio para el marco

    function setup() {
        createCanvas(800, 400);

        // Inicializar paletas y bola
        playerPaddle = new Paddle(true);
        computerPaddle = new Paddle(false);
        ball = new Ball();
    }

    function draw() {
        background(0);

        // Mostrar puntaje
        displayScores();

        // Mostrar el marco del juego
        drawBorder();

        // Mostrar y mover las paletas y la bola
        playerPaddle.show();
        playerPaddle.move();

        computerPaddle.show();
        computerPaddle.aiMove(ball);

        ball.show();
        ball.move();

        // Detectar colisiones con las paletas
        ball.checkPaddleCollision(playerPaddle);
        ball.checkPaddleCollision(computerPaddle);

        // Verificar si alguien ha anotado
        ball.checkScore();
    }

    class Paddle {
        constructor(isPlayer) {
            this.width = 20;
            this.height = 100;
            this.x = isPlayer ? PADDING + 10 : width - PADDING - 30;
            this.y = height / 2 - this.height / 2;
            this.isPlayer = isPlayer;
        }

        show() {
            fill(255);
            rect(this.x, this.y, this.width, this.height);
        }

        move() {
            if (this.isPlayer) {
                this.y = constrain(mouseY - this.height / 2, PADDING, height - PADDING - this.height);
            }
        }

        aiMove(ball) {
            if (!this.isPlayer) {
                if (ball.y < this.y + this.height / 2) {
                    this.y -= 5;
                } else if (ball.y > this.y + this.height / 2) {
                    this.y += 5;
                }
                this.y = constrain(this.y, PADDING, height - PADDING - this.height);
            }
        }
    }

    class Ball {
        constructor() {
            this.size = 20;
            this.reset();
        }

        reset() {
            this.x = width / 2;
            this.y = height / 2;
            this.xSpeed = random([-5, 5]);
            this.ySpeed = random(-3, 3);
        }

        show() {
            fill(255);
            ellipse(this.x, this.y, this.size, this.size);
        }

        move() {
            this.x += this.xSpeed;
            this.y += this.ySpeed;

            if (this.y <= PADDING || this.y >= height - PADDING) {
                this.ySpeed *= -1;
            }
        }

        checkPaddleCollision(paddle) {
            if (this.x - this.size / 2 < paddle.x + paddle.width &&
                this.x + this.size / 2 > paddle.x &&
                this.y - this.size / 2 < paddle.y + paddle.height &&
                this.y + this.size / 2 > paddle.y) {
                this.xSpeed *= -1;
                this.x = paddle.isPlayer ? paddle.x + paddle.width + this.size / 2 : paddle.x - this.size / 2;
            }
        }

        checkScore() {
            if (this.x < PADDING) {
                computerScore++;
                this.reset();
            } else if (this.x > width - PADDING) {
                playerScore++;
                this.reset();
            }
        }
    }

    function displayScores() {
        textAlign(CENTER);
        textSize(32);
        fill(255);
        text(playerScore, width / 4, 50);
        text(computerScore, 3 * width / 4, 50);
    }

    function drawBorder() {
        noFill();
        stroke(255);
        strokeWeight(4);
        rect(PADDING, PADDING, width - PADDING * 2, height - PADDING * 2);
    }
```

cambios en el css

```css
    body {
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #282c34;
    color: white;
    font-family: Arial, sans-serif;
    }

    canvas {
        border: 4px solid white;
        background-color: #000;
        box-shadow: 0px 0px 15px rgba(255, 255, 255, 0.5);
    }
```

Resultado:

![pong con marco](/imagenes/clase01/pong_con_marco.png)

### Respuestas mas directas

- En el proceso de desarrollo de un proyecto con la ayuda de ChatGPT, es común que necesitemos realizar cambios en partes específicas del código.

Sin embargo, muchas veces notamos que al solicitar un cambio, el modelo termina repitiendo información que no se modificará junto con lo solicitado. Esto retrasa el proceso de generar la respuesta.

- Si puede detectar dónde se necesita un cambio, intente agregar esta información específica en su indicador. De esta manera, ChatGPT comprenderá mejor su intención y brindará una respuesta más precisa, que contenga solo la información que necesita modificar.

Esto puede ayudar a que el proceso sea más rápido y eficiente, permitiéndole dedicar más tiempo a otras actividades del proyecto.