## Solicitando modificaciones

- Si no tiene indicador de puntaje pegar el codigo javascript en la IA y pedirle que agregue el puntaje a cada jugador
- Para aumentar la dificultad del juego tambien pedir que cambie el angulo al chocar con la raqueta

```javascript
    --  prompt procesa el siguiente codigo. no des respuesta.
    ```
        let playerPaddle, computerPaddle, ball;
        let playerScore = 0, computerScore = 0;
        const PADDING = 10; // Espacio para el marco

        function setup() {
            createCanvas(800, 400);

            // Inicializar paletas y bola
            playerPaddle = new Paddle(true);
            computerPaddle = new Paddle(false);
            ball = new Ball();
        }

        function draw() {
            background(0);

            // Mostrar puntaje
            displayScores();

            // Mostrar el marco del juego
            drawBorder();

            // Mostrar y mover las paletas y la bola
            playerPaddle.show();
            playerPaddle.move();

            computerPaddle.show();
            computerPaddle.aiMove(ball);

            ball.show();
            ball.move();

            // Detectar colisiones con las paletas
            ball.checkPaddleCollision(playerPaddle);
            ball.checkPaddleCollision(computerPaddle);

            // Verificar si alguien ha anotado
            ball.checkScore();
        }

        class Paddle {
            constructor(isPlayer) {
                this.width = 20;
                this.height = 100;
                this.x = isPlayer ? PADDING + 10 : width - PADDING - 30;
                this.y = height / 2 - this.height / 2;
                this.isPlayer = isPlayer;
            }

            show() {
                fill(255);
                rect(this.x, this.y, this.width, this.height);
            }

            move() {
                if (this.isPlayer) {
                    this.y = constrain(mouseY - this.height / 2, PADDING, height - PADDING - this.height);
                }
            }

            aiMove(ball) {
                if (!this.isPlayer) {
                    if (ball.y < this.y + this.height / 2) {
                        this.y -= 5;
                    } else if (ball.y > this.y + this.height / 2) {
                        this.y += 5;
                    }
                    this.y = constrain(this.y, PADDING, height - PADDING - this.height);
                }
            }
        }

        class Ball {
            constructor() {
                this.size = 20;
                this.reset();
            }

            reset() {
                this.x = width / 2;
                this.y = height / 2;
                this.xSpeed = random([-5, 5]);
                this.ySpeed = random(-3, 3);
            }

            show() {
                fill(255);
                ellipse(this.x, this.y, this.size, this.size);
            }

            move() {
                this.x += this.xSpeed;
                this.y += this.ySpeed;

                if (this.y <= PADDING || this.y >= height - PADDING) {
                    this.ySpeed *= -1;
                }
            }

            checkPaddleCollision(paddle) {
                if (this.x - this.size / 2 < paddle.x + paddle.width &&
                    this.x + this.size / 2 > paddle.x &&
                    this.y - this.size / 2 < paddle.y + paddle.height &&
                    this.y + this.size / 2 > paddle.y) {
                    this.xSpeed *= -1;
                    this.x = paddle.isPlayer ? paddle.x + paddle.width + this.size / 2 : paddle.x - this.size / 2;
                }
            }

            checkScore() {
                if (this.x < PADDING) {
                    computerScore++;
                    this.reset();
                } else if (this.x > width - PADDING) {
                    playerScore++;
                    this.reset();
                }
            }
        }

        function displayScores() {
            textAlign(CENTER);
            textSize(32);
            fill(255);
            text(playerScore, width / 4, 50);
            text(computerScore, 3 * width / 4, 50);
        }

        function drawBorder() {
            noFill();
            stroke(255);
            strokeWeight(4);
            rect(PADDING, PADDING, width - PADDING * 2, height - PADDING * 2);
        }
    ```
```

prompt: "modifica el codigo para que cuando la pelota choque con la raqueta el angulo de rebote sea aleatorio."

Respuesta:

```javascript
    let playerPaddle, computerPaddle, ball;
    let playerScore = 0, computerScore = 0;
    const PADDING = 10; // Espacio para el marco

    function setup() {
        createCanvas(800, 400);

        // Inicializar paletas y bola
        playerPaddle = new Paddle(true);
        computerPaddle = new Paddle(false);
        ball = new Ball();
    }

    function draw() {
        background(0);

        // Mostrar puntaje
        displayScores();

        // Mostrar el marco del juego
        drawBorder();

        // Mostrar y mover las paletas y la bola
        playerPaddle.show();
        playerPaddle.move();

        computerPaddle.show();
        computerPaddle.aiMove(ball);

        ball.show();
        ball.move();

        // Detectar colisiones con las paletas
        ball.checkPaddleCollision(playerPaddle);
        ball.checkPaddleCollision(computerPaddle);

        // Verificar si alguien ha anotado
        ball.checkScore();
    }

    class Paddle {
        constructor(isPlayer) {
            this.width = 20;
            this.height = 100;
            this.x = isPlayer ? PADDING + 10 : width - PADDING - 30;
            this.y = height / 2 - this.height / 2;
            this.isPlayer = isPlayer;
        }

        show() {
            fill(255);
            rect(this.x, this.y, this.width, this.height);
        }

        move() {
            if (this.isPlayer) {
                this.y = constrain(mouseY - this.height / 2, PADDING, height - PADDING - this.height);
            }
        }

        aiMove(ball) {
            if (!this.isPlayer) {
                if (ball.y < this.y + this.height / 2) {
                    this.y -= 5;
                } else if (ball.y > this.y + this.height / 2) {
                    this.y += 5;
                }
                this.y = constrain(this.y, PADDING, height - PADDING - this.height);
            }
        }
    }

    class Ball {
        constructor() {
            this.size = 20;
            this.reset();
        }

        reset() {
            this.x = width / 2;
            this.y = height / 2;
            this.xSpeed = random([-5, 5]);
            this.ySpeed = random(-3, 3);
        }

        show() {
            fill(255);
            ellipse(this.x, this.y, this.size, this.size);
        }

        move() {
            this.x += this.xSpeed;
            this.y += this.ySpeed;

            if (this.y <= PADDING || this.y >= height - PADDING) {
                this.ySpeed *= -1;
            }
        }

        checkPaddleCollision(paddle) {
            if (this.x - this.size / 2 < paddle.x + paddle.width &&
                this.x + this.size / 2 > paddle.x &&
                this.y - this.size / 2 < paddle.y + paddle.height &&
                this.y + this.size / 2 > paddle.y) {

                // Invertir la dirección en x
                this.xSpeed *= -1;

                // Generar un ángulo de rebote aleatorio
                this.ySpeed = random(-5, 5);

                // Ajustar la posición de la pelota para evitar quedar atrapada en la paleta
                this.x = paddle.isPlayer ? paddle.x + paddle.width + this.size / 2 : paddle.x - this.size / 2;
            }
        }

        checkScore() {
            if (this.x < PADDING) {
                computerScore++;
                this.reset();
            } else if (this.x > width - PADDING) {
                playerScore++;
                this.reset();
            }
        }
    }

    function displayScores() {
        textAlign(CENTER);
        textSize(32);
        fill(255);
        text(playerScore, width / 4, 50);
        text(computerScore, 3 * width / 4, 50);
    }

    function drawBorder() {
        noFill();
        stroke(255);
        strokeWeight(4);
        rect(PADDING, PADDING, width - PADDING * 2, height - PADDING * 2);
    }

```

prompt: "mejorar el codigo para que el angulo de rebote este entre -45 grados y 45 grados. ya que se quiere aumentar la dificultad del juego"

Respuesta:

```javascript	
    let playerPaddle, computerPaddle, ball;
    let playerScore = 0, computerScore = 0;
    const PADDING = 10; // Espacio para el marco

    function setup() {
        createCanvas(800, 400);

        // Inicializar paletas y bola
        playerPaddle = new Paddle(true);
        computerPaddle = new Paddle(false);
        ball = new Ball();
    }

    function draw() {
        background(0);

        // Mostrar puntaje
        displayScores();

        // Mostrar el marco del juego
        drawBorder();

        // Mostrar y mover las paletas y la bola
        playerPaddle.show();
        playerPaddle.move();

        computerPaddle.show();
        computerPaddle.aiMove(ball);

        ball.show();
        ball.move();

        // Detectar colisiones con las paletas
        ball.checkPaddleCollision(playerPaddle);
        ball.checkPaddleCollision(computerPaddle);

        // Verificar si alguien ha anotado
        ball.checkScore();
    }

    class Paddle {
        constructor(isPlayer) {
            this.width = 20;
            this.height = 100;
            this.x = isPlayer ? PADDING + 10 : width - PADDING - 30;
            this.y = height / 2 - this.height / 2;
            this.isPlayer = isPlayer;
        }

        show() {
            fill(255);
            rect(this.x, this.y, this.width, this.height);
        }

        move() {
            if (this.isPlayer) {
                this.y = constrain(mouseY - this.height / 2, PADDING, height - PADDING - this.height);
            }
        }

        aiMove(ball) {
            if (!this.isPlayer) {
                if (ball.y < this.y + this.height / 2) {
                    this.y -= 5;
                } else if (ball.y > this.y + this.height / 2) {
                    this.y += 5;
                }
                this.y = constrain(this.y, PADDING, height - PADDING - this.height);
            }
        }
    }

    class Ball {
        constructor() {
            this.size = 20;
            this.reset();
        }

        reset() {
            this.x = width / 2;
            this.y = height / 2;
            this.speed = 5;
            this.angle = random([-1, 1]) * random(PI / 4); // Ángulo entre -45 y 45 grados en radianes
            this.xSpeed = this.speed * cos(this.angle);
            this.ySpeed = this.speed * sin(this.angle);
        }

        show() {
            fill(255);
            ellipse(this.x, this.y, this.size, this.size);
        }

        move() {
            this.x += this.xSpeed;
            this.y += this.ySpeed;

            if (this.y <= PADDING || this.y >= height - PADDING) {
                this.ySpeed *= -1;
            }
        }

        checkPaddleCollision(paddle) {
            if (this.x - this.size / 2 < paddle.x + paddle.width &&
                this.x + this.size / 2 > paddle.x &&
                this.y - this.size / 2 < paddle.y + paddle.height &&
                this.y + this.size / 2 > paddle.y) {

                // Invertir la dirección en x
                this.xSpeed *= -1;

                // Generar un ángulo de rebote entre -45 y 45 grados
                this.angle = map(this.y - (paddle.y + paddle.height / 2), -paddle.height / 2, paddle.height / 2, -PI / 4, PI / 4);

                // Ajustar las velocidades en x e y según el nuevo ángulo
                this.xSpeed = this.speed * cos(this.angle) * (paddle.isPlayer ? 1 : -1);
                this.ySpeed = this.speed * sin(this.angle);

                // Ajustar la posición de la pelota para evitar quedar atrapada en la paleta
                this.x = paddle.isPlayer ? paddle.x + paddle.width + this.size / 2 : paddle.x - this.size / 2;
            }
        }

        checkScore() {
            if (this.x < PADDING) {
                computerScore++;
                this.reset();
            } else if (this.x > width - PADDING) {
                playerScore++;
                this.reset();
            }
        }
    }

    function displayScores() {
        textAlign(CENTER);
        textSize(32);
        fill(255);
        text(playerScore, width / 4, 50);
        text(computerScore, 3 * width / 4, 50);
    }

    function drawBorder() {
        noFill();
        stroke(255);
        strokeWeight(4);
        rect(PADDING, PADDING, width - PADDING * 2, height - PADDING * 2);
    }
```

Ejemplos y mas recomendaciones:

https://www.youtube.com/watch?v=r5T2aO9YXb0


## Corrigiendo bugs

- Para la clase existe un bug que se desaparece la pelota cuando rebota
- El instructor la revisa y corrige el error en el codigo
- Se encuentra que el codigo de la IA cambia el angulo en vertical y en horizontal causando efectos extraños en el rebote de la pelota, demostrando alusinaciones que ha generado la IA
- como no se nota efecto con los 45 grados se ajusta el codigo a pi/3 es decir ahora con 60 grados de apertura
- Con esto se demuestra que la IA ayuda a crear el codigo pero somos nosotros quienes debemos revisar y evaluar la respuesta
