## Desafios

1. Supón que el gobierno determine un cambio en el formato del número de la Cédula Profesional de los médicos, que a partir de ahora debe seguir el siguiente patrón: XXXXXX-XX/MX.

En la clase DatosRegistroMedico el atributo cedulaProfesional está anotado con:

@Pattern(regexp = "\\d{4,6}")

Respuesta:

```markdown
Dado que el gobierno ha determinado un nuevo formato para el número de la Cédula Profesional de los médicos, que debe seguir el patrón `XXXXXX-XX/MX`, la expresión regular actual en la clase `DatosRegistroMedico`, que es `@Pattern(regexp = "\\d{4,6}")`, no es suficiente para validar este nuevo formato.

### Nuevo Formato Requerido: `XXXXXX-XX/MX`

Vamos a desglosar el nuevo formato:

- **`XXXXXX`**: Seis dígitos (pueden ser entre 4 y 6 dígitos).
- **`-`**: Un guion.
- **`XX`**: Dos letras, pueden ser cualquier letra.
- **`/`**: Una barra diagonal.
- **`MX`**: Las letras "MX", que son constantes.

### Nueva Expresión Regular:

Para validar el nuevo formato, la expresión regular en la anotación `@Pattern` debería modificarse de la siguiente manera:

```java
@Pattern(regexp = "^\\d{4,6}-[A-Z]{2}/MX$")
```

### Desglose de la Nueva Expresión Regular:

1. **`^`**:
   - Indica el inicio de la cadena.

2. **`\\d{4,6}`**:
   - `\\d` representa un dígito numérico (0-9).
   - `{4,6}` especifica que debe haber entre 4 y 6 dígitos.

3. **`-`**:
   - Representa un guion literal.

4. **`[A-Z]{2}`**:
   - `[A-Z]` es un rango que representa cualquier letra mayúscula del alfabeto inglés.
   - `{2}` indica que debe haber exactamente dos letras.

5. **`/`**:
   - Representa una barra diagonal literal.

6. **`MX`**:
   - Las letras "MX" son constantes y deben aparecer tal cual.

7. **`$`**:
   - Indica el final de la cadena.

### Ejemplo de Cédula Profesional que Cumple con el Nuevo Formato:

- `123456-AB/MX`
- `9876-CD/MX`

Con esta nueva expresión regular, la anotación en la clase `DatosRegistroMedico` validará que el atributo `cedulaProfesional` siga el formato requerido.
```

## 2. Supón que te encontraste con el siguiente código SQL en una aplicación que estás desarrollando:

```sql
   SELECT 
      p.categoria, 
      c.pais, 
      COUNT(*) AS total_productos
   FROM 
      productos p
   JOIN categorias c ON p.id_categoria = c.id
   WHERE 
      p.precio > 100
   GROUP BY p.categoria, c.pais
   HAVING COUNT(*) > 5
   ORDER BY total_productos DESC;
   
   -- Entendiste la mayor parte del comando anterior, excepto el fragmento que contiene la cláusula GROUP BY. -- -- Utiliza ChatGPT para que te ayude a entender el código SQL anterior.
```

Respuesta:

```markdown
Vamos a desglosar el código SQL que proporcionaste, centrándonos en la cláusula `GROUP BY` y cómo funciona en el contexto de esta consulta.

### Código SQL Desglosado

```sql
   SELECT 
      p.categoria, 
      c.pais, 
      COUNT(*) AS total_productos
   FROM productos p
   JOIN categorias c ON p.id_categoria = c.id
   WHERE p.precio > 100
   GROUP BY p.categoria, c.pais
   HAVING COUNT(*) > 5
   ORDER BY total_productos DESC;
```

### 1. **SELECT**
   - **`p.categoria`**: Selecciona la categoría de los productos desde la tabla `productos`.
   - **`c.pais`**: Selecciona el país asociado desde la tabla `categorias`.
   - **`COUNT(*) AS total_productos`**: Cuenta el número total de productos que coinciden con los criterios y lo devuelve como `total_productos`.

### 2. **FROM y JOIN**
   - **`FROM productos p`**: Establece que la consulta se ejecutará sobre la tabla `productos`, con el alias `p`.
   - **`JOIN categorias c ON p.id_categoria = c.id`**: Realiza una unión entre la tabla `productos` y `categorias`, utilizando la columna `id_categoria` de `productos` y `id` de `categorias` para encontrar las categorías correspondientes a cada producto.

### 3. **WHERE**
   - **`p.precio > 100`**: Filtra los productos para que solo se incluyan aquellos cuyo precio es mayor a 100.

### 4. **GROUP BY**
   - **`p.categoria, c.pais`**: Esta cláusula agrupa los resultados de la consulta por la categoría de los productos (`p.categoria`) y el país (`c.pais`).
   - **¿Qué hace esto?**: Cuando usas `GROUP BY`, estás agrupando filas que tienen los mismos valores en las columnas especificadas. En este caso, agrupa todas las filas que tienen la misma categoría y país, de manera que la función `COUNT(*)` cuente el número de productos en cada combinación de categoría y país.

### 5. **HAVING**
   - **`HAVING COUNT(*) > 5`**: Filtra los grupos creados por `GROUP BY` para incluir solo aquellos en los que el número de productos es mayor a 5. Es similar a `WHERE`, pero se aplica después de que los datos han sido agrupados.

### 6. **ORDER BY**
   - **`ORDER BY total_productos DESC`**: Ordena los resultados por el número total de productos en orden descendente, mostrando primero las categorías y países con más productos.

### Resumen de `GROUP BY`

La cláusula `GROUP BY` toma los resultados de la consulta y los agrupa según los valores de las columnas que se especifican (en este caso, `p.categoria` y `c.pais`). Esto significa que todos los productos que tienen la misma categoría y están en el mismo país se agruparán en una sola fila. Luego, la función `COUNT(*)` contará cuántos productos hay en cada grupo, y `HAVING` se asegurará de que solo se incluyan los grupos con más de 5 productos.

En resumen, este código SQL obtiene un resumen de cuántos productos (con precio mayor a 100) existen por categoría y país, pero solo incluye en el resultado aquellos casos donde hay más de 5 productos en ese grupo, y luego ordena estos resultados por la cantidad total de productos de mayor a menor.
```

